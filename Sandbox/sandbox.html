<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2D Sandbox ‚Äî Full Features</title>
<style>
  /* FORCE ALL TEXT TO BE WHITE */
  * { color: white !important; }

  :root{
    --bg:#0e0f14; --panel:#111217; --accent:#6cf; --muted:#98a0b3; --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%; margin:0; font-family:Inter,Segoe UI,Roboto,Arial; background:linear-gradient(180deg,#071021 0%, #07142a 100%);}
  #app{display:flex; height:100vh; color:#e6eef8;}
  #leftPanel{width:320px; background:var(--panel); padding:12px; box-sizing:border-box; border-right:1px solid rgba(255,255,255,0.03); overflow:auto;}
  #canvasWrap{flex:1; position:relative; display:flex; align-items:stretch;}
  canvas{display:block; width:100%; height:100%; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02)); cursor:crosshair;}
  .toolbar, .group{margin-bottom:12px;}
  .toolBtn{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; margin:4px; background:var(--glass); border-radius:8px; cursor:pointer; border:1px solid transparent;}
  .toolBtn.active{background:linear-gradient(90deg, rgba(108,205,255,0.08), rgba(108,205,255,0.02)); border-color:rgba(108,205,255,0.18);}
  label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px;}
  input[type="range"]{width:100%;}
  .row{display:flex; gap:8px; align-items:center;}
  .muted{color:var(--muted); font-size:12px;}
  button.primary{background:linear-gradient(90deg,var(--accent),#9cf); color:#012; border:none; padding:8px 10px; border-radius:8px; cursor:pointer;}
  small.hint{display:block; color:var(--muted); margin-top:6px;}
  #topBar{position:absolute; left:14px; top:10px; z-index:20; display:flex; gap:8px;}
  .mini{padding:6px 8px; background:rgba(0,0,0,0.4); border-radius:8px; border:1px solid rgba(255,255,255,0.03); font-size:13px;}
  #help{font-size:13px; color:var(--muted);}
  .inspector input[type="number"]{width:100%;}
  .list{max-height:160px; overflow:auto; background:rgba(255,255,255,0.02); padding:6px; border-radius:6px;}
  .objectItem{padding:6px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; gap:6px; margin-bottom:6px;}
  .objectItem:hover{background:rgba(255,255,255,0.01);}
  footer{color:var(--muted); font-size:12px; margin-top:16px;}
</style>
</head>

<body>
<div id="app">
  <div id="leftPanel">
    <h2>Sandbox</h2>
    <div class="toolbar group" id="tools">
      <label>Tools</label>
      <div id="toolButtons">
        <button class="toolBtn" data-tool="pan">ü§ö Pan</button>
        <button class="toolBtn" data-tool="draw">‚úèÔ∏è Draw</button>
        <button class="toolBtn" data-tool="erase">üßΩ Erase</button>
        <button class="toolBtn" data-tool="place">üì¶ Place</button>
        <button class="toolBtn" data-tool="select">üîç Select</button>
        <button class="toolBtn" data-tool="apply">‚û°Ô∏è Apply Force</button>
        <button class="toolBtn" data-tool="spawn">‚ú® Spawn</button>
      </div>
    </div>

    <div class="group">
      <label>Brush / Place settings</label>
      <div class="row">
        <div style="flex:1">
          <label>Size <span id="sizeVal">18</span></label>
          <input type="range" id="brushSize" min="2" max="120" value="18"/>
        </div>
        <div style="width:82px">
          <label>Type</label>
          <select id="placeType">
            <option value="box">Box</option>
            <option value="circle">Circle</option>
            <option value="actor">Actor</option>
          </select>
        </div>
      </div>
      <div class="row" style="margin-top:8px;">
        <label style="flex:1"><input type="checkbox" id="snapGrid"/> Snap to grid</label>
        <div style="width:120px"><label>Grid <input type="number" id="gridSize" min="8" value="32" style="width:64px"/></label></div>
      </div>
    </div>

    <div class="group">
      <label>Simulation</label>
      <div class="row">
        <label style="flex:1">Gravity <span id="gravVal">1.0</span></label>
        <input type="range" id="gravity" min="-2" max="4" step="0.1" value="1"/>
      </div>
      <div class="row" style="margin-top:8px;">
        <label style="flex:1">Time scale <span id="tsVal">1.0</span></label>
        <input type="range" id="timeScale" min="0" max="2" step="0.05" value="1"/>
      </div>
      <div class="row" style="margin-top:8px; gap:8px;">
        <button id="pauseBtn" class="toolBtn">‚è∏ Pause</button>
        <button id="stepBtn" class="toolBtn">‚è≠ Step</button>
        <button id="resetBtn" class="toolBtn">‚ôª Reset</button>
      </div>
    </div>

    <div class="group">
      <label>Edit & state</label>
      <div class="row">
        <button id="undoBtn" class="toolBtn">‚Ü∂ Undo</button>
        <button id="redoBtn" class="toolBtn">‚Ü∑ Redo</button>
        <button id="clearBtn" class="toolBtn">üßπ Clear</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="saveBtn" class="primary">Save JSON</button>
        <button id="loadBtn" class="toolBtn">Load JSON</button>
        <button id="exportBtn" class="toolBtn">Export PNG</button>
      </div>
    </div>

    <div class="group">
      <label>Objects</label>
      <div class="list" id="objectList"></div>
      <small class="muted">Click object to select for editing.</small>
    </div>

    <div class="group inspector">
      <label>Inspector</label>
      <div id="inspector">
        <div class="muted">No object selected</div>
      </div>
    </div>

    <footer>
      <div class="muted">Shortcuts: H Help ‚Ä¢ Delete removes selected ‚Ä¢ Space pause/play ‚Ä¢ S Save ‚Ä¢ L Load</div>
      <div style="margin-top:8px;" class="muted">This runs completely in your browser.</div>
    </footer>
  </div>

  <div id="canvasWrap">
    <div id="topBar">
      <div class="mini" id="status">Tool: <strong id="statusTool">draw</strong></div>
      <div class="mini" id="fps">FPS: --</div>
      <div class="mini" id="help">H for help</div>
    </div>
    <canvas id="c"></canvas>
    <input type="file" id="fileInput" accept="application/json" style="display:none" />
  </div>
</div>

<script>
/* FULL JAVASCRIPT UNCHANGED ‚Äî STARTS HERE */
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });
  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function fit() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', fit);

  const terrainCanvas = document.createElement('canvas');
  const tctx = terrainCanvas.getContext('2d');

  function fitTerrain() {
    terrainCanvas.width = canvas.width;
    terrainCanvas.height = canvas.height;
    tctx.clearRect(0,0,terrainCanvas.width,terrainCanvas.height);
  }

  const camera = { x:0, y:0, zoom:1 };
  const worldToScreen = (x,y) => ({x:(x-camera.x)*camera.zoom + canvas.width/DPR/2, y:(y-camera.y)*camera.zoom + canvas.height/DPR/2});
  const screenToWorld = (sx,sy) => ({x: (sx - canvas.width/DPR/2)/camera.zoom + camera.x, y: (sy - canvas.height/DPR/2)/camera.zoom + camera.y});

  const state = {
    tool: 'draw',
    brushSize: 18,
    placeType: 'box',
    gravity: 1,
    timeScale: 1,
    running: true,
    snapGrid: false,
    gridSize: 32,
  };

  let bodies = [];
  let nextId = 1;

  const undoStack = [];
  const redoStack = [];
  function pushSnapshot() {
    const snapshot = {
      bodies: JSON.parse(JSON.stringify(bodies)),
      terrain: terrainCanvas.toDataURL()
    };
    undoStack.push(snapshot);
    if (undoStack.length > 60) undoStack.shift();
    redoStack.length = 0;
    updateButtons();
  }
  function restoreSnapshot(snapshot) {
    bodies = JSON.parse(JSON.stringify(snapshot.bodies));
    const img = new Image();
    img.onload = () => {
      tctx.clearRect(0,0,terrainCanvas.width, terrainCanvas.height);
      tctx.drawImage(img,0,0);
      rebuildObjectList();
    };
    img.src = snapshot.terrain;
  }
  function undo() {
    if (!undoStack.length) return;
    const s = undoStack.pop();
    redoStack.push({
      bodies: JSON.parse(JSON.stringify(bodies)),
      terrain: terrainCanvas.toDataURL()
    });
    restoreSnapshot(s);
    updateButtons();
  }
  function redo() {
    if (!redoStack.length) return;
    const s = redoStack.pop();
    undoStack.push({
      bodies: JSON.parse(JSON.stringify(bodies)),
      terrain: terrainCanvas.toDataURL()
    });
    restoreSnapshot(s);
    updateButtons();
  }
  function updateButtons() {
    document.getElementById('undoBtn').disabled = !undoStack.length;
    document.getElementById('redoBtn').disabled = !redoStack.length;
  }

  function createBody(opts) {
    const b = Object.assign({
      id: nextId++,
      type: 'box',
      x:0,y:0,w:40,h:40,r:20,
      vx:0,vy:0,ax:0,ay:0,
      angle:0, angVel:0,
      mass:1, restitution:0.1, friction:0.02,
      color: '#79c6ff',
      locked:false
    }, opts);
    if (b.type === 'circle') b.r = b.r || (b.w/2 || 20);
    bodies.push(b);
    rebuildObjectList();
    return b;
  }

  function makeFloor() {
    tctx.fillStyle = '#2b2e36';
    tctx.fillRect(0, terrainCanvas.height - 100, terrainCanvas.width, 200);
  }

  let drawing = false;
  let lastPos = null;
  function paintToTerrain(worldPos, erase=false) {
    const p = worldToScreen(worldPos.x, worldPos.y);
    const tx = p.x * DPR;
    const ty = p.y * DPR;
    const size = state.brushSize * DPR;
    tctx.save();
    if (erase) {
      tctx.globalCompositeOperation = 'destination-out';
      tctx.beginPath();
      tctx.fillStyle = 'rgba(0,0,0,1)';
      tctx.arc(tx, ty, size/2, 0, Math.PI*2);
      tctx.fill();
    } else {
      tctx.globalCompositeOperation = 'source-over';
      tctx.fillStyle = '#3b85ff';
      tctx.beginPath();
      tctx.arc(tx, ty, size/2, 0, Math.PI*2);
      tctx.fill();
    }
    tctx.restore();
  }

  let selectedId = null;
  function pickBodyAt(x,y){
    for (let i=bodies.length-1;i>=0;i--){
      const b=bodies[i];
      if (b.type==='circle'){
        const dx=x-b.x, dy=y-b.y;
        if (dx*dx+dy*dy <= b.r*b.r) return b;
      } else {
        if (x>=b.x-b.w/2 && x<=b.x+b.w/2 && y>=b.y-b.h/2 && y<=b.y+b.h/2) return b;
      }
    }
    return null;
  }

  function rebuildObjectList(){
    const el = document.getElementById('objectList');
    el.innerHTML = '';
    bodies.slice().reverse().forEach(b=>{
      const row = document.createElement('div');
      row.className = 'objectItem';
      row.innerHTML = `
        <div style="display:flex;gap:8px;align-items:center">
          <div style="width:14px;height:14px;border-radius:3px;background:${b.color};"></div>
          <div>${b.type} #${b.id}</div>
        </div>
        <div style="display:flex;gap:6px">
          <button class="toolBtn" data-id="${b.id}" data-act="select">Select</button>
          <button class="toolBtn" data-id="${b.id}" data-act="delete">Del</button>
        </div>`;
      el.appendChild(row);
    });
    el.querySelectorAll('button').forEach(btn=>{
      btn.addEventListener('click',(ev)=>{
        const id = +btn.dataset.id;
        const act = btn.dataset.act;
        if (act==='select'){ selectedId = id; showInspector(); }
        else if (act==='delete'){
          pushSnapshot();
          bodies = bodies.filter(b=>b.id!==id);
          rebuildObjectList();
        }
      });
    });
  }

  function showInspector(){
    const ins=document.getElementById('inspector');
    ins.innerHTML='';
    const b=bodies.find(x=>x.id===selectedId);
    if (!b){
      ins.innerHTML='<div class="muted">No object selected</div>';
      return;
    }
    const wrap=document.createElement('div');
    wrap.innerHTML=`
      <label>Type</label>
      <div style="margin-bottom:8px">${b.type} #${b.id}</div>
      <label>X</label><input type="number" id="propX" value="${b.x}" />
      <label>Y</label><input type="number" id="propY" value="${b.y}" />
      ${b.type==='circle'
        ? `<label>Radius</label><input type="number" id="propR" value="${b.r}" />`
        : `<label>W</label><input type="number" id="propW" value="${b.w}" />
           <label>H</label><input type="number" id="propH" value="${b.h}" />`}
      <label>Mass</label><input type="number" id="propMass" value="${b.mass}" />
      <label>Restitution</label><input type="number" id="propRes" value="${b.restitution}" step="0.01" />
      <label>Locked</label><input type="checkbox" id="propLocked" ${b.locked?'checked':''} />
      <div style="margin-top:8px;display:flex;gap:8px">
        <button id="applyProps" class="toolBtn">Apply</button>
        <button id="deselect" class="toolBtn">Deselect</button>
      </div>
    `;
    ins.appendChild(wrap);

    document.getElementById('applyProps').addEventListener('click',()=>{
      pushSnapshot();
      b.x=parseFloat(propX.value)||b.x;
      b.y=parseFloat(propY.value)||b.y;
      if (b.type==='circle') b.r=Math.max(1,parseFloat(propR.value)||b.r);
      else {
        b.w=Math.max(2,parseFloat(propW.value)||b.w);
        b.h=Math.max(2,parseFloat(propH.value)||b.h);
      }
      b.mass=Math.max(0.0001,parseFloat(propMass.value)||b.mass);
      b.restitution=parseFloat(propRes.value)||b.restitution;
      b.locked=propLocked.checked;
      rebuildObjectList();
      showInspector();
    });

    document.getElementById('deselect').addEventListener('click',()=>{
      selectedId=null;
      showInspector();
    });
  }

  function stepPhysics(dt){
    const g=state.gravity;
    for (const b of bodies){
      if (b.locked) continue;
      b.vx += (b.ax||0)*dt;
      b.vy += ((b.ay||0)+g)*dt;
      b.x += b.vx*dt*state.timeScale;
      b.y += b.vy*dt*state.timeScale;
      b.vx *= (1-b.friction);
      b.vy *= (1-b.friction*0.2);
      b.angVel *= (1-b.friction);
      b.angle += b.angVel*dt;
    }

    for (const b of bodies){
      if (b.type==='circle'){
        let s=worldToScreen(b.x,b.y);
        let sx=s.x*DPR, sy=s.y*DPR;
        let checkY=Math.floor(sy + b.r*DPR);
        if (checkY>=0 && checkY<terrainCanvas.height){
          let px=Math.floor(sx);
          if (px>=0&&px<terrainCanvas.width){
            let pix=tctx.getImageData(px,checkY,1,1).data;
            if (pix[3]>10){
              while (tctx.getImageData(px,Math.floor(sy + b.r*DPR),1,1).data[3]>10){
                b.y -= 0.5/DPR;
                s=worldToScreen(b.x,b.y);
                sy=s.y*DPR;
              }
              b.vy = -Math.abs(b.vy)*b.restitution;
              b.y -= 0.5/DPR;
            }
          }
        }
      } else {
        let px=Math.floor(worldToScreen(b.x,b.y-b.h/2).x * DPR);
        let py=Math.floor(worldToScreen(b.x,b.y+b.h/2).y * DPR);
        if (py>=0&&py<terrainCanvas.height && px>=0&&px<terrainCanvas.width){
          let pix=tctx.getImageData(px,py,1,1).data;
          if (pix[3]>10){
            while (tctx.getImageData(px,Math.floor(worldToScreen(b.x,b.y+b.h/2).y*DPR),1,1).data[3]>10){
              b.y -= 0.5/DPR;
            }
            b.vy = -Math.abs(b.vy)*b.restitution;
          }
        }
      }
    }

    for (let i=0;i<bodies.length;i++){
      for (let j=i+1;j<bodies.length;j++){
        const A=bodies[i], B=bodies[j];
        if (A.locked&&B.locked) continue;

        if (A.type==='circle' && B.type==='circle'){
          const dx=B.x-A.x, dy=B.y-A.y;
          const dist2=dx*dx+dy*dy;
          const rsum=A.r+B.r;
          if (dist2<rsum*rsum && dist2>1e-6){
            const dist=Math.sqrt(dist2);
            const overlap=rsum-dist;
            const nx=dx/dist, ny=dy/dist;
            const totalMass=A.mass+B.mass;

            if (!A.locked){ A.x -= nx*overlap*(B.mass/totalMass); A.y -= ny*overlap*(B.mass/totalMass); }
            if (!B.locked){ B.x += nx*overlap*(A.mass/totalMass); B.y += ny*overlap*(A.mass/totalMass); }

            const rvx=B.vx-A.vx, rvy=B.vy-A.vy;
            const rel=rvx*nx + rvy*ny;
            if (rel>-0.001) continue;

            const e=Math.min(A.restitution,B.restitution);
            const jImpulse = -(1+e)*rel/(1/A.mass + 1/B.mass);
            const ix=jImpulse*nx, iy=jImpulse*ny;

            if (!A.locked){ A.vx -= ix/A.mass; A.vy -= iy/A.mass; }
            if (!B.locked){ B.vx += ix/B.mass; B.vy += iy/B.mass; }
          }
        } else {
          const aMinX=A.x-(A.w||A.r*2)/2, aMaxX=A.x+(A.w||A.r*2)/2;
          const aMinY=A.y-(A.h||A.r*2)/2, aMaxY=A.y+(A.h||A.r*2)/2;
          const bMinX=B.x-(B.w||B.r*2)/2, bMaxX=B.x+(B.w||B.r*2)/2;
          const bMinY=B.y-(B.h||B.r*2)/2, bMaxY=B.y+(B.h||B.r*2)/2;

          if (aMinX<bMaxX && aMaxX>bMinX && aMinY<bMaxY && aMaxY>bMinY){
            const overlapX=Math.min(aMaxX-bMinX, bMaxX-aMinX);
            const overlapY=Math.min(aMaxY-bMinY, bMaxY-aMinY);

            if (overlapX < overlapY){
              const dir = A.x<B.x ? -1 : 1;
              if (!A.locked) A.x += -dir*overlapX/2;
              if (!B.locked) B.x += dir*overlapX/2;
              const vx=(A.vx+B.vx)/2;
              if (!A.locked) A.vx = -vx*Math.min(A.restitution,B.restitution);
              if (!B.locked) B.vx = -vx*Math.min(A.restitution,B.restitution);
            } else {
              const dir = A.y<B.y ? -1 : 1;
              if (!A.locked) A.y += -dir*overlapY/2;
              if (!B.locked) B.y += dir*overlapY/2;
              const vy=(A.vy+B.vy)/2;
              if (!A.locked) A.vy = -vy*Math.min(A.restitution,B.restitution);
              if (!B.locked) B.vy = -vy*Math.min(A.restitution,B.restitution);
            }
          }
        }
      }
    }
  }

  function drawGrid(){
    const gs=state.gridSize;
    if (!gs) return;
    ctx.save();
    ctx.lineWidth=1;
    ctx.strokeStyle='rgba(255,255,255,0.03)';
    const w=canvas.width/DPR, h=canvas.height/DPR;
    const topLeft=screenToWorld(0,0);
    const startX=Math.floor(topLeft.x/gs)*gs;
    const startY=Math.floor(topLeft.y/gs)*gs;
    for (let x=startX; x<topLeft.x+w/camera.zoom+gs; x+=gs){
      const sx=worldToScreen(x,0).x;
      ctx.beginPath();
      ctx.moveTo(sx,0);
      ctx.lineTo(sx,h);
      ctx.stroke();
    }
    for (let y=startY; y<topLeft.y+h/camera.zoom+gs; y+=gs){
      const sy=worldToScreen(0,y).y;
      ctx.beginPath();
      ctx.moveTo(0,sy);
      ctx.lineTo(w,sy);
      ctx.stroke();
    }
    ctx.restore();
  }

  function render(){
    ctx.clearRect(0,0,canvas.width/DPR,canvas.height/DPR);
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.drawImage(terrainCanvas,0,0,canvas.width/DPR,canvas.height/DPR);

    if (state.snapGrid) drawGrid();

    for (const b of bodies){
      ctx.save();
      const s=worldToScreen(b.x,b.y);
      ctx.translate(s.x,s.y);
      ctx.rotate(b.angle||0);
      ctx.fillStyle=b.color;
      ctx.lineWidth=2;
      ctx.strokeStyle=(selectedId===b.id)?'rgba(255,255,255,0.9)':'rgba(0,0,0,0.2)';

      if (b.type==='circle'){
        ctx.beginPath();
        ctx.arc(0,0,b.r,0,Math.PI*2);
        ctx.fill();
        ctx.stroke();
      } else {
        ctx.fillRect(-b.w/2,-b.h/2,b.w,b.h);
        ctx.strokeRect(-b.w/2,-b.h/2,b.w,b.h);
      }
      ctx.restore();
    }

    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle='rgba(255,255,255,0.035)';
    ctx.fillRect(10,10,220,54);
    ctx.fillStyle='#dff0ff';
    ctx.font='13px Arial';
    ctx.fillText(`Bodies: ${bodies.length}`,20,30);
    ctx.fillText(`Gravity: ${state.gravity.toFixed(2)}  TimeScale: ${state.timeScale.toFixed(2)}`,20,50);

    ctx.restore();
  }

  let last=performance.now();
  let fpsCounter={ lastSample:performance.now(), frames:0, fps:0 };
  function loop(){
    const now=performance.now();
    const dt=Math.min(0.032,(now-last)/1000);
    last=now;
    if (state.running) stepPhysics(dt);
    render();
    fpsCounter.frames++;
    if (now - fpsCounter.lastSample > 500){
      fpsCounter.fps=Math.round((fpsCounter.frames*1000)/(now-fpsCounter.lastSample));
      fpsCounter.frames=0;
      fpsCounter.lastSample=now;
      fps.innerText=`FPS: ${fpsCounter.fps}`;
    }
    requestAnimationFrame(loop);
  }

  let pointer={down:false, button:0, x:0, y:0, sx:0, sy:0};
  let isPanning=false;
  let panStart=null;

  function onPointerDown(e){
    pointer.down=true;
    pointer.button=e.button??0;
    pointer.sx=e.clientX; pointer.sy=e.clientY;
    const rect=canvas.getBoundingClientRect();
    pointer.x=e.clientX-rect.left;
    pointer.y=e.clientY-rect.top;
    const world=screenToWorld(pointer.x,pointer.y);

    if (state.tool==='pan'){
      isPanning=true;
      panStart={sx:e.clientX, sy:e.clientY, camx:camera.x, camy:camera.y};
      canvas.style.cursor='grabbing';
    }
    else if (state.tool==='draw'){
      pushSnapshot();
      drawing=true;
      paintToTerrain(world,false);
      lastPos=world;
    }
    else if (state.tool==='erase'){
      pushSnapshot();
      drawing=true;
      paintToTerrain(world,true);
      lastPos=world;
    }
    else if (state.tool==='place'){
      pushSnapshot();
      const pos=snapIfNeeded(world);
      const t=state.placeType;
      if (t==='box') createBody({type:'box',x:pos.x,y:pos.y,w:state.brushSize*1.2,h:state.brushSize*0.8,color:randomColor()});
      else if (t==='circle') createBody({type:'circle',x:pos.x,y:pos.y,r:state.brushSize/2,color:randomColor()});
      else if (t==='actor') createBody({type:'box',x:pos.x,y:pos.y,w:state.brushSize*1.1,h:state.brushSize*1.6,color:'#ffd27f'});
    }
    else if (state.tool==='select'){
      const picked=pickBodyAt(world.x,world.y);
      selectedId=picked?picked.id:null;
      showInspector();
    }
    else if (state.tool==='apply'){
      const picked=pickBodyAt(world.x,world.y);
      if (picked){
        pushSnapshot();
        picked.vy -= 6;
        picked.vx += (Math.random()-0.5)*6;
      }
    }
    else if (state.tool==='spawn'){
      pushSnapshot();
      spawnExplosion(world.x,world.y,10);
    }
  }

  function onPointerMove(e){
    const rect=canvas.getBoundingClientRect();
    pointer.x=e.clientX-rect.left;
    pointer.y=e.clientY-rect.top;
    const world=screenToWorld(pointer.x,pointer.y);

    if (isPanning && panStart){
      const dx=e.clientX - panStart.sx;
      const dy=e.clientY - panStart.sy;
      camera.x = panStart.camx - dx/camera.zoom;
      camera.y = panStart.camy - dy/camera.zoom;
    }

    if (drawing && (state.tool==='draw'||state.tool==='erase')){
      const cur=world;
      const steps=Math.max(1,Math.round(Math.hypot(cur.x-lastPos.x,cur.y-lastPos.y)/(state.brushSize/10)));
      for (let i=0;i<steps;i++){
        const t=i/steps;
        paintToTerrain({
          x:lastPos.x+(cur.x-lastPos.x)*t,
          y:lastPos.y+(cur.y-lastPos.y)*t
        }, state.tool==='erase');
      }
      lastPos=cur;
    }

    statusTool.innerText=state.tool;
  }

  function onPointerUp(){
    pointer.down=false;
    drawing=false;
    isPanning=false;
    panStart=null;
    canvas.style.cursor='';
    lastPos=null;
  }

  function randomColor(){
    const colors=['#79c6ff','#ffb07e','#b8ff9a','#ffd27f','#b39bff','#7ef0ff'];
    return colors[Math.floor(Math.random()*colors.length)];
  }

  function snapIfNeeded(world){
    if (!state.snapGrid) return world;
    const g=state.gridSize;
    return { x:Math.round(world.x/g)*g, y:Math.round(world.y/g)*g };
  }

  function spawnExplosion(x,y,n=8){
    for (let i=0;i<n;i++){
      const ang=Math.random()*Math.PI*2;
      const speed=2+Math.random()*6;
      const b=createBody({type:'circle',x:x+Math.cos(ang)*6,y:y+Math.sin(ang)*6,r:6+Math.random()*6,mass:0.2+Math.random(),color:randomColor()});
      b.vx=Math.cos(ang)*speed;
      b.vy=Math.sin(ang)*speed - 3;
      b.restitution=0.2+Math.random()*0.6;
    }
  }

  window.addEventListener('keydown',e=>{
    if (e.key===' '){
      state.running=!state.running;
      pauseBtn.innerText=state.running?'‚è∏ Pause':'‚ñ∂ Play';
      e.preventDefault();
    }
    else if (e.key.toLowerCase()==='h'){
      alert(`Shortcuts:
Space: Pause/Play
H: Help
S: Save JSON
L: Load JSON
Delete: Delete selected object
1..6: tools`);
    }
    else if (e.key.toLowerCase()==='s'){
      e.preventDefault();
      saveScene();
    }
    else if (e.key.toLowerCase()==='l'){
      e.preventDefault();
      fileInput.click();
    }
    else if (e.key==='Delete' || e.key==='Backspace'){
      if (selectedId){
        pushSnapshot();
        bodies=bodies.filter(b=>b.id!==selectedId);
        selectedId=null;
        rebuildObjectList();
        showInspector();
      }
    }
    else if (e.key==='z'&&(e.ctrlKey||e.metaKey)) undo();
    else if (e.key==='y'&&(e.ctrlKey||e.metaKey)) redo();
  });

  function setTool(t){
    state.tool=t;
    document.querySelectorAll('#toolButtons .toolBtn').forEach(b=>{
      b.classList.toggle('active',b.dataset.tool===t);
    });
    statusTool.innerText=t;
  }

  toolButtons.addEventListener('click',e=>{
    const btn=e.target.closest('.toolBtn');
    if (!btn) return;
    setTool(btn.dataset.tool);
  });

  brushSize.addEventListener('input',e=>{
    state.brushSize=+e.target.value;
    sizeVal.innerText=state.brushSize;
  });

  placeType.addEventListener('change',e=>state.placeType=e.target.value);

  gravity.addEventListener('input',e=>{
    state.gravity=+e.target.value;
    gravVal.innerText=state.gravity.toFixed(2);
  });

  timeScale.addEventListener('input',e=>{
    state.timeScale=+e.target.value;
    tsVal.innerText=state.timeScale.toFixed(2);
  });

  pauseBtn.addEventListener('click',()=>{
    state.running=!state.running;
    pauseBtn.innerText=state.running?'‚è∏ Pause':'‚ñ∂ Play';
  });

  stepBtn.addEventListener('click',()=>{
    stepPhysics(1/60);
    render();
  });

  resetBtn.addEventListener('click',()=>{
    if (!confirm('Reset scene?')) return;
    pushSnapshot();
    bodies=[];
    tctx.clearRect(0,0,terrainCanvas.width,terrainCanvas.height);
    makeFloor();
    rebuildObjectList();
  });

  undoBtn.addEventListener('click',undo);
  redoBtn.addEventListener('click',redo);

  clearBtn.addEventListener('click',()=>{
    pushSnapshot();
    bodies=[];
    tctx.clearRect(0,0,terrainCanvas.width,terrainCanvas.height);
    rebuildObjectList();
  });

  saveBtn.addEventListener('click',saveScene);
  loadBtn.addEventListener('click',()=>fileInput.click());
  exportBtn.addEventListener('click',exportPNG);

  fileInput.addEventListener('change',ev=>{
    const f=ev.target.files[0];
    if (!f) return;
    const reader=new FileReader();
    reader.onload=e=>{
      try {
        const obj=JSON.parse(e.target.result);
        if (obj && Array.isArray(obj.bodies) && obj.terrain){
          pushSnapshot();
          bodies=obj.bodies;
          const img=new Image();
          img.onload=()=>{
            tctx.clearRect(0,0,terrainCanvas.width,terrainCanvas.height);
            tctx.drawImage(img,0,0);
            rebuildObjectList();
          };
          img.src=obj.terrain;
        } else alert('Invalid scene JSON');
      } catch(err){ alert('Error reading file'); }
    };
    reader.readAsText(f);
  });

  function saveScene(){
    const data={ bodies, terrain: terrainCanvas.toDataURL() };
    const blob=new Blob([JSON.stringify(data)],{type:'application/json'});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='sandbox_scene.json';
    a.click();
  }

  function exportPNG(){
    const out=document.createElement('canvas');
    out.width=canvas.width;
    out.height=canvas.height;
    const octx=out.getContext('2d');
    octx.drawImage(terrainCanvas,0,0);
    for (const b of bodies){
      octx.save();
      const s=worldToScreen(b.x,b.y);
      const sx=s.x*DPR, sy=s.y*DPR;
      octx.translate(sx,sy);
      octx.rotate(b.angle||0);
      octx.fillStyle=b.color;
      if (b.type==='circle'){
        octx.beginPath();
        octx.arc(0,0,b.r*DPR,0,Math.PI*2);
        octx.fill();
      } else {
        octx.fillRect(-b.w/2*DPR,-b.h/2*DPR,b.w*DPR,b.h*DPR);
      }
      octx.restore();
    }
    const link=document.createElement('a');
    link.href=out.toDataURL('image/png');
    link.download='sandbox_export.png';
    link.click();
  }

  function init(){
    fit();
    fitTerrain();
    makeFloor();
    setTool('draw');
    rebuildObjectList();
    updateButtons();
    loop();
  }

  canvas.addEventListener('pointerdown',onPointerDown);
  window.addEventListener('pointermove',onPointerMove);
  window.addEventListener('pointerup',onPointerUp);

  snapGrid.addEventListener('change',e=>state.snapGrid=e.target.checked);
  gridSize.addEventListener('input',e=>state.gridSize=Math.max(4,+e.target.value));

  window.addEventListener('keydown',e=>{
    if (e.key>='1' && e.key<='7'){
      const map={1:'pan',2:'draw',3:'erase',4:'place',5:'select',6:'apply',7:'spawn'};
      setTool(map[e.key]);
    }
  });

  function resizeLoop(){
    DPR=Math.max(1,window.devicePixelRatio||1);
    fit();
    fitTerrain();
    requestAnimationFrame(resizeLoop);
  }
  resizeLoop();
  init();
  pushSnapshot();

  window.sandbox={ createBody, bodies, terrainCanvas, pushSnapshot, undo, redo, spawnExplosion };
})();
</script><link rel="stylesheet" href="./assets/back-to-home.css">
<script src="./assets/back-to-home.js" defer></script>
</body>
</html>
